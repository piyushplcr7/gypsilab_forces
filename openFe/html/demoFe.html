
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Class Fe</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-09-15"><meta name="DC.source" content="demoFe.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Class Fe</h1><!--introduction--><p>This class represents spaces of finite element functions. An instance of Fe represents a vector space <img src="demoFe_eq13706143497907411324.png" alt="$V_h = $ Span $({\phi_1,...,\phi_n})$"> where <img src="demoFe_eq12318961823750766280.png" alt="$\phi_i$"> are Finite Element functions defined on a mesh. By finite element functions, we mean the following conditions:</p><p>- There exists a set of points <img src="demoFe_eq16377755534236194672.png" alt="$x_1,...,x_n$"> on the mesh, called dofs, such that <img src="demoFe_eq00253071940804472188.png" alt="$\phi_i(x_j) = 0$"> for <img src="demoFe_eq04305824717510817134.png" alt="$j \neq i$"> and <img src="demoFe_eq07052763711842285065.png" alt="$\phi_i(x_i) = 1$"> for all <img src="demoFe_eq05671228016298599287.png" alt="$i$">.</p><p>- Each element E of the mesh is the image of the reference domain <img src="demoFe_eq00754786616917444931.png" alt="$S = [0,1]$"> by an affine mapping <img src="demoFe_eq05138859483679567593.png" alt="$\chi_E$">. There exist B (basis) functions <img src="demoFe_eq05366620435860321455.png" alt="$\psi_1,...,\psi_B$"> defined on S, and points <img src="demoFe_eq07662319464151457316.png" alt="$X_1,...,X_B$"> (reference dofs) of S such that <img src="demoFe_eq00862199054382476770.png" alt="$\psi_i(X_b) = \delta_{i,b}$">. For every <img src="demoFe_eq18096895394918367257.png" alt="$f$"> in <img src="demoFe_eq07017236538874501370.png" alt="$V_h$">, there holds <img src="demoFe_eq12224064478421135596.png" alt="$f = \sum_{E} \sum_{b = 1}^B f(x_{i(E,b)})\phi_b \circ \chi_j^{-1}$"> almost everywhere.</p><p>- Each dof <img src="demoFe_eq08383031602117067423.png" alt="$x_i$"> located on an element E coincides with <img src="demoFe_eq03138955599914057807.png" alt="$\chi_E(X_b)$"> for some <img src="demoFe_eq02044268985122151499.png" alt="$b$">. If <img src="demoFe_eq08383031602117067423.png" alt="$x_i$"> is shared by several elements <img src="demoFe_eq17461473906112538115.png" alt="$e_1,...,e_M$">, then there exists <img src="demoFe_eq13925149539400391498.png" alt="$b_1,...,b_m$"> such that <img src="demoFe_eq17961715524793948060.png" alt="$x_i = \chi_{e_m}(X_{b_m})$"> for all <img src="demoFe_eq03427040122400487146.png" alt="$m = 1..M$">.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Abstract FE and concrete classes</a></li><li><a href="#2">Matrices of some relevant linear maps.</a></li></ul></div><h2 id="1">Abstract FE and concrete classes</h2><p>Fe.m is an abstract class. This means that one cannot create an instance of Fe.m. However, one can create concrete classes implementing Fe.m. This is due to the fact that many types of finite element functions exist, with some specific aspects (number of basis functions, location of the dofs,...) but they are involved in Galerkin computations with similar algorithms. The algorithms that are common to every type of Fe space are written directly in the abstract class. The concrete classes must implement only a few function to inherit from Fe. Those are</p><p>- X,dof_jb = dof(obj), which returns the coordinates of the dofs on the mesh and an array dof_jb such that, for each element e_j and index b, dof_jb(j,b) = i where <img src="demoFe_eq05671228016298599287.png" alt="$i$"> is such that that <img src="demoFe_eq17906868498265798276.png" alt="$x_i = \chi_{e_j}(X_b)$">.</p><p>- r = psi_b(obj,b,x), which, given some reference coordinates x and an index b, returns the <img src="demoFe_eq10413784110355029125.png" alt="$\psi_b(x)$">.</p><p>- s = name(obj), which simply indicates the name of the finite element functions.</p><pre class="codeinput">clean;
c = openline(0,2); m = meshCurve(c,2);

<span class="comment">% Example 1:</span>
Vh = P0(m); <span class="comment">% Space of piecewise constant functions on the mesh.</span>
[X,dof_jb] = dof(Vh);
disp(<span class="string">'P0 dofs :'</span>)
disp(X);
disp(<span class="string">'P0 dof_jb'</span>)
disp(dof_jb);
figure
plot(m);
hold <span class="string">on</span>
plot(X(:,1),X(:,2),<span class="string">'r*'</span>,<span class="string">'DisplayName'</span>,<span class="string">'dofs'</span>);
legend <span class="string">show</span>
title(<span class="string">'P0 elements'</span>)

<span class="comment">% Example 2:</span>
Vh = P1(m); <span class="comment">% Space of piecewise linear functions on the mesh.</span>
[X,dof_jb] = dof(Vh);
disp(<span class="string">'P1 dofs :'</span>)
disp(X);
disp(<span class="string">'P1 dof_jb'</span>)
disp(dof_jb);
figure
plot(m);
hold <span class="string">on</span>
plot(X(:,1),X(:,2),<span class="string">'r*'</span>,<span class="string">'DisplayName'</span>,<span class="string">'dofs'</span>);
legend <span class="string">show</span>
title(<span class="string">'P1 elements'</span>)

<span class="comment">% Example 3:</span>
Vh = P2(m); <span class="comment">% Space of piecewise quadratic functions on the mesh.</span>
[X,dof_jb] = dof(Vh);
disp(<span class="string">'P2 dofs :'</span>)
disp(X);
disp(<span class="string">'P2 dof_jb'</span>)
disp(dof_jb);
figure
plot(m);
hold <span class="string">on</span>
plot(X(:,1),X(:,2),<span class="string">'r*'</span>,<span class="string">'DisplayName'</span>,<span class="string">'dofs'</span>);
legend <span class="string">show</span>
title(<span class="string">'P2 elements'</span>);
</pre><pre class="codeoutput">P0 dofs :
    0.5000         0
    1.5000         0

P0 dof_jb
     1
     2

P1 dofs :
     0     0
     1     0
     2     0

P1 dof_jb
     1     2
     2     3

P2 dofs :
         0         0
    1.0000         0
    2.0000         0
    0.5000         0
    1.5000         0

P2 dof_jb
     1     4     2
     2     5     3

</pre><img vspace="5" hspace="5" src="demoFe_01.png" alt=""> <img vspace="5" hspace="5" src="demoFe_02.png" alt=""> <img vspace="5" hspace="5" src="demoFe_03.png" alt=""> <h2 id="2">Matrices of some relevant linear maps.</h2><p>In Galerkin Boundary Element methods, the linear systems take the form</p><p><img src="demoFe_eq17842642868441019336.png" alt="$$ A_{ij} = \int_{D \times D} (K \phi_i)(x) G(x,y) (L\phi_j)(y) \,dx\,dy $$"></p><p>where <img src="demoFe_eq16171345478199012472.png" alt="$D$"> is a domain of integration and <img src="demoFe_eq03845174387838694102.png" alt="$K$"> and <img src="demoFe_eq11904963258706611165.png" alt="$L$"> are some linear operators (possibily identity) and <img src="demoFe_eq07365524530707038546.png" alt="$G$"> is a possibily singular kernel. Using Gaussian quadratures and ignoring the singularity integrals for the time being, this takes the form</p><p><img src="demoFe_eq04228968207719643345.png" alt="$$ A_{i,j} \approx \sum_{k,l} \omega_{k,l} (K\phi_i)(x_k) G(x_k, y_l) (L\phi_j)(x_l) $$"></p><p>This can be written compactly as <img src="demoFe_eq06784118805072364442.png" alt="$A \approx M_K M_G M_L$"> where</p><p>- <img src="demoFe_eq10998051985860512414.png" alt="$M_G$"> is the matrix given by <img src="demoFe_eq01549333488650204242.png" alt="$(G(x_k,y_l))_{k,l}$"></p><p>- <img src="demoFe_eq07655677476943083243.png" alt="$M_L$"> is the matrix of the linear map which, to the values of a member of <img src="demoFe_eq15489911991930495347.png" alt="$u \in V_h$"> at the dofs, associates the values of <img src="demoFe_eq02929787717664750098.png" alt="$Lu$"> at the points <img src="demoFe_eq12190275882934088920.png" alt="$(x_k)$">.</p><p>In the particular case where <img src="demoFe_eq07041154681402670254.png" alt="$L = I_d$">, the column <img src="demoFe_eq05671228016298599287.png" alt="$i$"> of <img src="demoFe_eq07655677476943083243.png" alt="$M_L$"> is simply the evalutation of <img src="demoFe_eq12318961823750766280.png" alt="$\phi_i$"> at the points <img src="demoFe_eq12190275882934088920.png" alt="$(x_k)$">. This matrix can be computed by the following command:</p><pre class="codeinput"><span class="comment">% P1 :</span>
Vh = P1(m);
Y = [linspace(0,2,100)', zeros(100,1)];<span class="comment">% Query points</span>
X = dof(Vh);
M = dof2Y(Vh,Y);
figure
plot(m);
hold <span class="string">on</span>
plot(X(:,1),X(:,2),<span class="string">'r*'</span>)
plot(Y(:,1),full(M));
legend(<span class="string">'vertices'</span>,<span class="string">'dofs'</span>,<span class="string">'phi_1'</span>,<span class="string">'phi_2'</span>,<span class="string">'phi_3'</span>)
title(<span class="string">'P1 elements'</span>)

<span class="comment">% P2 :</span>
Vh = P2(m);
Y = [linspace(0,2,600)', zeros(600,1)];<span class="comment">% Query points</span>
X = dof(Vh);
M = dof2Y(Vh,Y);
figure
plot(m);
hold <span class="string">on</span>
plot(X(:,1),X(:,2),<span class="string">'r*'</span>)
plot(Y(:,1),full(M));
legend(<span class="string">'vertices'</span>,<span class="string">'dofs'</span>,<span class="string">'phi_1'</span>,<span class="string">'phi_2'</span>,<span class="string">'phi_3'</span>,<span class="string">'phi_4'</span>,<span class="string">'phi_5'</span>)
title(<span class="string">'P2 elements'</span>)
</pre><img vspace="5" hspace="5" src="demoFe_04.png" alt=""> <img vspace="5" hspace="5" src="demoFe_05.png" alt=""> <p>If L is not the identity mapping, just compute the matrix by M = dof2Y(L(Vh),Y). If <img src="demoFe_eq04377909619180012562.png" alt="$L(\phi_i)$"> has several componenents (for example if L is defined by <img src="demoFe_eq16779561898897958571.png" alt="$L\phi = \phi \vec{n}$"> where <img src="demoFe_eq05696126968202063231.png" alt="$\vec{n}$"> is the normal vector on the mesh), then M will be returned as a cell with M{k} containing the matrix of the k-th component of <img src="demoFe_eq11904963258706611165.png" alt="$L$">.</p><pre class="codeinput"><span class="comment">% Example: tangential gradient of P2 elements</span>
Vh = P2(m);
Y = [linspace(0,2,600)', zeros(600,1)];<span class="comment">% Query points</span>
X = dof(Vh);
M = dof2Y(grad(Vh),Y);
figure
plot(X(:,1),X(:,2),<span class="string">'r*'</span>)
hold <span class="string">on</span>
plot(Y(:,1),full(M));
legend(<span class="string">'dofs'</span>,<span class="string">'grad(phi_1)'</span>,<span class="string">'grad(phi_2)'</span>,<span class="string">'grad(phi_3)'</span>,<span class="string">'grad(phi_4)'</span>,<span class="string">'grad(phi_5)'</span>)
title(<span class="string">'grad(P2) elements'</span>)
axis <span class="string">auto</span>
xlim([0,2])
ylim([-4,4])

<span class="comment">% Example: multiplication by x of P1 elements</span>
m = meshCurve(circle,7);
Vh = P1(m);
X = dof(Vh);
Y = linspace(m,20);
M = dof2Y(xtimes(Vh),Y);
figure
plot(X(:,1),X(:,2),<span class="string">'r*'</span>)
hold <span class="string">on</span>
plot(Y(:,1),full(M{1}));
plot(m)
title(<span class="string">'x1 * P1 elements'</span>)
figure
plot(X(:,1),X(:,2),<span class="string">'r*'</span>)
hold <span class="string">on</span>
plot(Y(:,1),full(M{2}));
plot(m)
title(<span class="string">'x2 * P1 elements'</span>)
</pre><img vspace="5" hspace="5" src="demoFe_06.png" alt=""> <img vspace="5" hspace="5" src="demoFe_07.png" alt=""> <img vspace="5" hspace="5" src="demoFe_08.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Class Fe
% This class represents spaces of finite element functions. 
% An instance of Fe represents a vector space
% $V_h = $ Span $({\phi_1,...,\phi_n})$ where $\phi_i$ are Finite Element functions
% defined on a mesh. By finite element functions, we mean the following
% conditions:
% 
% - There exists a set of points $x_1,...,x_n$ on the mesh, called dofs,
% such that $\phi_i(x_j) = 0$ for $j \neq i$ and $\phi_i(x_i) = 1$ for all $i$.
% 
% - Each element E of the mesh is the image of the reference domain $S = [0,1]$ by
% an affine mapping $\chi_E$. There exist B (basis) functions
% $\psi_1,...,\psi_B$ defined on S, and points $X_1,...,X_B$ (reference dofs) of S such that
% $\psi_i(X_b) = \delta_{i,b}$. For every $f$ in $V_h$, there holds
% $f = \sum_{E} \sum_{b = 1}^B f(x_{i(E,b)})\phi_b \circ \chi_j^{-1}$ almost
% everywhere.
% 
% - Each dof $x_i$ located on an element E coincides with $\chi_E(X_b)$ for
% some $b$. If $x_i$ is shared by several elements $e_1,...,e_M$, then there
% exists $b_1,...,b_m$ such that $x_i = \chi_{e_m}(X_{b_m})$ for all $m =
% 1..M$.
    
%% Abstract FE and concrete classes
% Fe.m is an abstract class. This means that one cannot create an instance
% of Fe.m. However, one can create concrete classes implementing Fe.m. This
% is due to the fact that many types of finite element functions exist,
% with some specific aspects (number of basis functions, location of the
% dofs,...) but they are involved in Galerkin computations with similar
% algorithms. The algorithms that are common to every type of Fe space are
% written directly in the abstract class. The concrete classes must
% implement only a few function to inherit from Fe. Those are 
% 
% - X,dof_jb = dof(obj), which returns the coordinates of the dofs on the
% mesh and an array dof_jb such that, for each element e_j and index b, 
% dof_jb(j,b) = i where $i$ is such that that $x_i = \chi_{e_j}(X_b)$.
% 
% - r = psi_b(obj,b,x), which, given some reference coordinates x and an
% index b, returns the $\psi_b(x)$. 
% 
% - s = name(obj), which simply indicates the name of the finite element
% functions. 


clean;
c = openline(0,2); m = meshCurve(c,2);

% Example 1:
Vh = P0(m); % Space of piecewise constant functions on the mesh. 
[X,dof_jb] = dof(Vh);
disp('P0 dofs :')
disp(X); 
disp('P0 dof_jb')
disp(dof_jb);
figure
plot(m);
hold on
plot(X(:,1),X(:,2),'r*','DisplayName','dofs');
legend show
title('P0 elements')

% Example 2:
Vh = P1(m); % Space of piecewise linear functions on the mesh. 
[X,dof_jb] = dof(Vh);
disp('P1 dofs :')
disp(X); 
disp('P1 dof_jb')
disp(dof_jb);
figure
plot(m);
hold on
plot(X(:,1),X(:,2),'r*','DisplayName','dofs');
legend show
title('P1 elements')

% Example 3:
Vh = P2(m); % Space of piecewise quadratic functions on the mesh. 
[X,dof_jb] = dof(Vh);
disp('P2 dofs :')
disp(X); 
disp('P2 dof_jb')
disp(dof_jb);
figure
plot(m);
hold on
plot(X(:,1),X(:,2),'r*','DisplayName','dofs');
legend show
title('P2 elements');

%% Matrices of some relevant linear maps. 
% In Galerkin Boundary Element methods, the linear systems take the form 
%
% $$ A_{ij} = \int_{D \times D} (K \phi_i)(x) G(x,y) (L\phi_j)(y) \,dx\,dy $$
% 
% where $D$ is a domain of integration and $K$ and $L$ are some linear 
% operators (possibily identity) and $G$ is a possibily singular kernel. Using Gaussian 
% quadratures and ignoring the singularity integrals for the time being, 
% this takes the form
% 
% $$ A_{i,j} \approx \sum_{k,l} \omega_{k,l} (K\phi_i)(x_k) G(x_k, y_l) (L\phi_j)(x_l) $$
% 
% This can be written compactly as $A \approx M_K M_G M_L$ where 
% 
% - $M_G$ is the matrix given by $(G(x_k,y_l))_{k,l}$
% 
% - $M_L$ is the matrix of the linear map which, to the values of a member of
% $u \in V_h$ at the dofs, associates the values of $Lu$ at the points
% $(x_k)$. 
% 
% In the particular case where $L = I_d$, the column $i$ of $M_L$ is simply
% the evalutation of $\phi_i$ at the points $(x_k)$. This matrix can be
% computed by the following command:

% P1 :
Vh = P1(m);
Y = [linspace(0,2,100)', zeros(100,1)];% Query points
X = dof(Vh);
M = dof2Y(Vh,Y);
figure
plot(m);
hold on
plot(X(:,1),X(:,2),'r*')
plot(Y(:,1),full(M));
legend('vertices','dofs','phi_1','phi_2','phi_3')
title('P1 elements')

% P2 :
Vh = P2(m);
Y = [linspace(0,2,600)', zeros(600,1)];% Query points
X = dof(Vh);
M = dof2Y(Vh,Y);
figure
plot(m);
hold on
plot(X(:,1),X(:,2),'r*')
plot(Y(:,1),full(M));
legend('vertices','dofs','phi_1','phi_2','phi_3','phi_4','phi_5')
title('P2 elements')

%%
% If L is not the identity mapping, just compute the matrix by M =
% dof2Y(L(Vh),Y). If $L(\phi_i)$ has several componenents (for example if L
% is defined by $L\phi = \phi \vec{n}$ where $\vec{n}$ is the normal vector
% on the mesh), then M will be returned as a cell with M{k} containing the
% matrix of the k-th component of $L$. 

% Example: tangential gradient of P2 elements
Vh = P2(m);
Y = [linspace(0,2,600)', zeros(600,1)];% Query points
X = dof(Vh);
M = dof2Y(grad(Vh),Y);
figure
plot(X(:,1),X(:,2),'r*')
hold on
plot(Y(:,1),full(M));
legend('dofs','grad(phi_1)','grad(phi_2)','grad(phi_3)','grad(phi_4)','grad(phi_5)')
title('grad(P2) elements')
axis auto
xlim([0,2])
ylim([-4,4])

% Example: multiplication by x of P1 elements
m = meshCurve(circle,7);
Vh = P1(m);
X = dof(Vh);
Y = linspace(m,20);
M = dof2Y(xtimes(Vh),Y);
figure
plot(X(:,1),X(:,2),'r*')
hold on
plot(Y(:,1),full(M{1}));
plot(m)
title('x1 * P1 elements')
figure
plot(X(:,1),X(:,2),'r*')
hold on
plot(Y(:,1),full(M{2}));
plot(m)
title('x2 * P1 elements')







##### SOURCE END #####
--></body></html>